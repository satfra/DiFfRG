(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Get["DiFfRG`"]
SetDirectory[GetDirectory[]];

$Assumptions=q>0&&k>0&&p>0&&Nc>0&&Nf>0&&-1<cos1<1&&T>0&&muq>=0;

AddExtraVars[
(*momentum variables*)
k,p,q0,p0,p0f,qf,q,muq,T,

(*regulators*)
RPhi,RPhidot,RQ,RQdot,
GPion,GPionInv,GSigma,GSigmaInv,GQ,

(*wavefunction renormalizations*)
ZQ,ZPhi,

(*anomalous dimensions*)
etaQ,etaPhi,


(*quark-meson scatterings*)
hPhi,d1hPhi,d2hPhi,

(*meson scatterings*)
d1V,d2V,d3V,d4V,d5V,

(*fields*)
sigma,rhoPhi,

(*propagators*)
GQ,GPhi];


(* ::Input::Initialization:: *)
TFlav[0,f1_,f2_]:=deltaFundFlav[f1,f2]/Sqrt[2Nf]

FunctionalD[expr_,v:(f_[_]|{f_[_],_Integer})..,OptionsPattern[]]:=Internal`InheritedBlock[{f},f/:D[f[x_],f[y_],NonConstants->{f}]:=DiracDelta[x-y];
f/:D[f,f[y_],NonConstants->{f}]:=DiracDelta[#-y]&;
D[expr,v,NonConstants->{f}]];
Taylor[func_,var_,order_]:=func+Total[Table[Symbol["d"~~ToString[n]~~ToString[func]]/n! Product[var[],{i,1,n}],{n,1,order}]]
\[Lambda]qbqm\[CapitalPi]n\[Sigma][pions_,sigmas_,d1_,c1_,f1_,d2_,c2_,f2_]:=Module[{action,sigmaDeriv},
action=Taylor[hPhi,((sigma^2-sigma0^2)+Module[{b},\[CapitalPi][b]^2])/2&,Length[pions]+sigmas](sigma TFlav[0,f1,f2]deltaDirac[d1,d2]+I Module[{c},\[CapitalPi][c]TFlav[c,f1,f2]]gamma5[d1,d2]);
sigmaDeriv=D[action,{sigma,sigmas}];
-deltaFundCol[c1,c2]If[Length[pions]>=1,
FunctionalD[sigmaDeriv,Map[\[CapitalPi][#]&,pions]/. List->Sequence]//.DiracDelta[x_-y_]->deltaAdjFlav[x,y]//.DiracDelta[-1+y_]->deltaAdjFlav[1,y]
,
sigmaDeriv
]//.{\[CapitalPi][a_]->0,sigma0->sigma,sigma->Sqrt[2rhoPhi],Derivative[n_][hPhi][a_]:>Symbol["d"<>ToString[n]<>"hPhi"]}//Simplify
]
\[Lambda]m\[CapitalPi]n\[Sigma][pions_,sigmas_]:=Module[{action,sigmaDeriv},
action=Taylor[V,((sigma^2-sigma0^2)+Module[{b},\[CapitalPi][b]^2])/2&,Length[pions]+sigmas];
sigmaDeriv=D[action,{sigma,sigmas}];
If[Length[pions]>=1,
FunctionalD[sigmaDeriv,Map[\[CapitalPi][#]&,pions]/. List->Sequence]//.DiracDelta[x_-y_]->deltaAdjFlav[x,y]//.DiracDelta[-1+y_]->deltaAdjFlav[1,y]
,
sigmaDeriv
]//.{\[CapitalPi][a_]->0,sigma0->sigma,sigma->Sqrt[2rhoPhi],Derivative[n_][V][a_]:>Symbol["d"<>ToString[n]<>"V"],V[a_]->V}//Simplify
]


PostTraceRulesMesonic={
RPhi[p_]:>RB[k^2,sps[p,p]],
RPhidot[p_]:>RBdot[k^2,sps[p,p]]-etaPhi RB[k^2,sps[p,p]],
GPionInv[p_]:>(sp[p,p]+d1V),
GSigmaInv[p_]:>(sp[p,p]+d1V+2rhoPhi d2V),
GPion[p_]:>1/(sp[p,p]+d1V+RPhi[p]),
GSigma[p_]:>1/(sp[p,p]+d1V+2rhoPhi d2V+RPhi[p])
};


(* ::Input::Initialization:: *)
PreTraceRulesMesonic={
(*Regulators*)
R\[CapitalPi]\[CapitalPi][{p1_,a1_,p2_,a2_}]:>deltaAdjFlav[a1,a2]RPhi[p2],
R\[Sigma]\[Sigma][{p1_,p2_}]:>RPhi[p2],

(*Regulator Derivatives*)
Rdot\[CapitalPi]\[CapitalPi][{p1_,a1_,p2_,a2_}]:>deltaAdjFlav[a1,a2] RPhidot[p2],
Rdot\[Sigma]\[Sigma][{p1_,p2_}]:>RPhidot[p2],

(*Inverse Propagators*)
\[CapitalGamma]\[CapitalPi]\[CapitalPi][{p1_,a1_,p2_,a2_}]:> deltaAdjFlav[a1,a2] GPionInv[p2],
\[CapitalGamma]\[Sigma]\[Sigma][{p1_,p2_}]:>GSigmaInv[p2],

(*Propagators*)
G\[CapitalPi]\[CapitalPi][{p1_,a1_,p2_,a2_}]:> deltaAdjFlav[a1,a2]GPion[p1],
G\[Sigma]\[Sigma][{p1_,p2_}]:>GSigma[p1],

(*Pure Meson Vertices*)
\[CapitalGamma]\[Sigma]\[Sigma]\[Sigma][{p1_,p2_,p3_}] :>\[Lambda]m\[CapitalPi]n\[Sigma][{},3],
\[CapitalGamma]\[CapitalPi]\[CapitalPi]\[Sigma][{p1_,a1_,p2_,a2_,p3_}] :>\[Lambda]m\[CapitalPi]n\[Sigma][{a1,a2},1] ,
\[CapitalGamma]\[CapitalPi]\[CapitalPi]\[Sigma]\[Sigma][{p1_,a1_,p2_,a2_,p3_,p4_}] :>\[Lambda]m\[CapitalPi]n\[Sigma][{a1,a2},2],
\[CapitalGamma]\[CapitalPi]\[CapitalPi]\[CapitalPi]\[CapitalPi][{p1_,a1_,p2_,a2_,p3_,a3_,p4_,a4_}]:>\[Lambda]m\[CapitalPi]n\[Sigma][{a1,a2,a3,a4},0],
\[CapitalGamma]\[Sigma]\[Sigma]\[Sigma]\[Sigma][{p1_,p2_,p3_,p4_}]:>\[Lambda]m\[CapitalPi]n\[Sigma][{},4],

(*Quark-Meson Vertices*)
\[CapitalGamma]\[Sigma]qbq[{p1_,p2_,d2_,c2_,f2_,p3_,d3_,c3_,f3_}] :>  \[Lambda]qbqm\[CapitalPi]n\[Sigma][{},1,d2,c2,f2,d3,c3,f3],
\[CapitalGamma]\[CapitalPi]qbq[{p1_,a1_,p2_,d2_,c2_,f2_,p3_,d3_,c3_,f3_}]:>\[Lambda]qbqm\[CapitalPi]n\[Sigma][{a1},0,d2,c2,f2,d3,c3,f3],

\[CapitalGamma]\[CapitalPi]\[Sigma]qbq[{p1_,a1_,p2_,p3_,d3_,c3_,f3_,p4_,d4_,c4_,f4_}]:>\[Lambda]qbqm\[CapitalPi]n\[Sigma][{a1},1,d3,c3,f3,d4,c4,f4],
\[CapitalGamma]\[CapitalPi]\[CapitalPi]qbq[{p1_,a1_,p2_,a2_,p3_,d3_,c3_,f3_,p4_,d4_,c4_,f4_}]:>\[Lambda]qbqm\[CapitalPi]n\[Sigma][{a1,a2},0,d3,c3,f3,d4,c4,f4],
\[CapitalGamma]\[Sigma]\[Sigma]qbq[{p1_,p2_,p3_,d3_,c3_,f3_,p4_,d4_,c4_,f4_}]:>\[Lambda]qbqm\[CapitalPi]n\[Sigma][{},2,d3,c3,f3,d4,c4,f4],

\[CapitalGamma]\[CapitalPi]\[Sigma]\[Sigma]qbq[{p1_,a1_,p2_,p3_,p4_,d4_,c4_,f4_,p5_,d5_,c5_,f5_}]:>\[Lambda]qbqm\[CapitalPi]n\[Sigma][{a1},2,d4,c4,f4,d5,c5,f5],
\[CapitalGamma]\[CapitalPi]\[CapitalPi]\[CapitalPi]qbq[{p1_,a1_,p2_,a2_,p3_,a3_,p4_,d4_,c4_,f4_,p5_,d5_,c5_,f5_}]:>\[Lambda]qbqm\[CapitalPi]n\[Sigma][{a1,a2,a3},0,d4,c4,f4,d5,c5,f5],
\[CapitalGamma]\[Sigma]\[Sigma]\[Sigma]qbq[{p1_,p2_,p3_,p4_,d4_,c4_,f4_,p5_,d5_,c5_,f5_}]:>\[Lambda]qbqm\[CapitalPi]n\[Sigma][{},3,d4,c4,f4,d5,c5,f5]
};

sanity=(\[CapitalGamma]\[CapitalPi]\[CapitalPi][{-p,a1,p,a2}]+R\[CapitalPi]\[CapitalPi][{-p,a1,p,a2}])G\[CapitalPi]\[CapitalPi][{p,a2,-p,a1}]//.PreTraceRulesMesonic//FormTrace;
sanity=sanity//.PostTraceRulesMesonic//ExpandScalarProductsFiniteT//FullSimplify;
Print[sanity," should be -1+\!\(\*SuperscriptBox[\(Nf\), \(2\)]\)"]

sanity=(\[CapitalGamma]\[Sigma]\[Sigma][{-p,p}]+R\[Sigma]\[Sigma][{-p,p}])G\[Sigma]\[Sigma][{p,-p}]//.PreTraceRulesMesonic//FormTrace;
sanity=sanity//.PostTraceRulesMesonic//ExpandScalarProductsFiniteT//FullSimplify;
Print[sanity," should be 1"]


PostTraceRulesQuarks={ 
RQ[p_]:>RF[k^2,sps[p,p]],
RQdot[p_]:>RFdot[k^2,sps[p,p]]-etaQ RF[k^2,sps[p,p]],
GQ[p_]:>1/((vec[p,0]+I muq)^2+hPhi^2 rhoPhi/Nf+sps[p,p](1+ RQ[p]/Sqrt[sps[p,p]])^2)
};


(* ::Input::Initialization:: *)
PreTraceRulesQuarks={
(*Regulators*)
Rqbq[{p1_,d1_,c1_, f1_,p2_,d2_, c2_,f2_}]:>deltaFundCol[c1,c2]deltaFundFlav[f1,f2] (I  psdash[p2,d1,d2]) RQ[p2]/Sqrt[sps[p2,p2]],

(*Regulator Derivatives*)
Rdotqbq[{p1_,d1_,c1_, f1_,p2_,d2_, c2_,f2_}]:>deltaFundCol[c1,c2]deltaFundFlav[f1,f2] (I  psdash[p2,d1,d2]) RQdot[p2]/Sqrt[sps[p2,p2]],

(*Inverse Propagators*)
\[CapitalGamma]qbq[{p1_,d1_,c1_, f1_,p2_,d2_, c2_,f2_}] :>
-deltaFundCol[c1,c2](
deltaFundFlav[f1,f2]((I (vec[p2,0]+I muq)gamma[0,d1,d2])+ I psdash[p2,d1,d2]+ (hPhi Sqrt[2rhoPhi])/Sqrt[2Nf] deltaDirac[d1,d2])
) ,

(*Propagators*)
Gqqb[{p1_,d1_,c1_, f1_,p2_,d2_, c2_,f2_}] :>(deltaFundCol[c1,c2](deltaFundFlav[f1,f2]((-I (vec[p1,0]+I muq)gamma[0,d1,d2])+( -I psdash[p1,d1,d2])(1+RQ[p1]/Sqrt[sps[p1,p1]])+  (hPhi Sqrt[2rhoPhi])/Sqrt[2Nf] deltaDirac[d1,d2]) )
)GQ[p1]
};

sanity=(\[CapitalGamma]qbq[{-q,d1,c1, f1,q,d2, c2,f2}]-Rqbq[{-q,d1,c1, f1,q,d2, c2,f2}])Gqqb[{q,d2, c2,f2,-q,d1,c1, f1}]//.PreTraceRulesQuarks//PreTrace;
sanity=sanity//FormTrace;
sanity=sanity//.PostTraceRulesQuarks//FullSimplify;
Print[sanity," should be -12 Nf"]
(*Must be -4 Nc Nf*)


(* ::Input::Initialization:: *)
PreTraceRules:=PreTraceRulesMesonic\[Union]PreTraceRulesQuarks\[Union]{d1hPhi->0,d2hPhi->0}


PostTraceRules:=PostTraceRulesMesonic\[Union]PostTraceRulesQuarks\[Union]{d1hPhi->0,d2hPhi->0}


(* ::Input::Initialization:: *)
fRGEq = {"Prefactor"->{1/2},
<|"type"->"Regulatordot", "indices"->{i,j}|>,
<|"type"->"Propagator", "indices"->{i,j}|>};


(* ::Input::Initialization:: *)
fields = <|
"bosonic"-> {
\[Sigma][p],
\[CapitalPi][p,{a}]
},
"fermionic"->{
{qb[p,{d,c,f}],q[p,{d,c,f}]}
}
|>;

Truncation= {{\[Sigma],\[Sigma]},{\[CapitalPi],\[CapitalPi]},{q,qb},(* propagators *)
(*{qb,qb,q,q},*)(* four-quark scatterings *)
{qb,q,\[Sigma]},{qb,q,\[CapitalPi]},{qb,q,\[Sigma],\[Sigma]},{qb,q,\[CapitalPi],\[CapitalPi]},{qb,q,\[Sigma],\[CapitalPi]},{qb,q,\[Sigma],\[Sigma],\[Sigma]},{qb,q,\[Sigma],\[Sigma],\[CapitalPi]},{qb,q,\[Sigma],\[CapitalPi],\[CapitalPi]},{qb,q,\[CapitalPi],\[CapitalPi],\[CapitalPi]}, (* quark-meson scatterings *)
 {\[Sigma],\[Sigma],\[Sigma]},{\[Sigma],\[CapitalPi],\[CapitalPi]},{\[Sigma],\[Sigma],\[Sigma],\[Sigma]},{\[Sigma],\[Sigma],\[CapitalPi],\[CapitalPi]},{\[CapitalPi],\[CapitalPi],\[CapitalPi],\[CapitalPi]}(* meson scatterings *)
};

SetupfRG= <|"MasterEquation"->fRGEq,
"FieldSpace"->fields,
"Truncation"->Truncation|>;

DiagramStyle={
q->Black,
\[CapitalPi]->{Red},
\[Sigma]->{Red,Dashed}
};


\!\(\*SuperscriptBox[\(RF\), 
TagBox[
RowBox[{"(", 
RowBox[{"0", ",", "1"}], ")"}],
Derivative],
MultilineFunction->None]\)[k2_,p2_]:=dq2RF[k2,p2] 
\!\(\*SuperscriptBox[\(RB\), 
TagBox[
RowBox[{"(", 
RowBox[{"0", ",", "1"}], ")"}],
Derivative],
MultilineFunction->None]\)[k2_,p2_]:=dq2RB[k2,p2]
\!\(\*SuperscriptBox[\(RFdot\), 
TagBox[
RowBox[{"(", 
RowBox[{"0", ",", "1"}], ")"}],
Derivative],
MultilineFunction->None]\)[k2_,p2_]:=dq2RFdot[k2,p2] 
\!\(\*SuperscriptBox[\(RBdot\), 
TagBox[
RowBox[{"(", 
RowBox[{"0", ",", "1"}], ")"}],
Derivative],
MultilineFunction->None]\)[k2_,p2_]:=dq2RBdot[k2,p2]


AddCodeOptimizeFunctions[RB[__],RF[__],RBdot[__],RFdot[__],dq2RF[__],dq2RB[__],dq2RFdot[__],dq2RBdot[__]]
ShowCodeOptimizeFunctions[]


(* ::Input::Initialization:: *)
(*Anomalous dimensions*)
kerneletaQ=<|"Path"->"qbq","Name"->"etaQ","Type"->"Quadratureq0","Angles"->1,"d"->4,"AD"->True,"ctype"->"double","Device"->"CPU"|>;
kerneletaPhi=<|"Path"->"PhiPhi","Name"->"etaPhi","Type"->"Quadratureq0","Angles"->1,"d"->4,"AD"->True,"ctype"->"double","Device"->"CPU"|>;

(*Mesons*)
kernelV=<|"Path"->"V","Name"->"V","Type"->"Quadrature","Angles"->0,"d"->3,"AD"->True,"ctype"->"double","Device"->"CPU"|>;
kernelhPhi=<|"Path"->"Phiqbq","Name"->"hPhi0","Type"->"Quadratureq0","Angles"->1,"d"->4,"AD"->False,"ctype"->"double","Device"->"CPU"|>;

kernels={
kerneletaQ,kerneletaPhi,
kernelV,kernelhPhi
};

kernelParameterList={
<|"Name"->"p0f","Type"->"Constant","AD"->False|>,
<|"Name"->"p","Type"->"Constant","AD"->False|>,

<|"Name"->"Nc","Type"->"Constant","AD"->False|>,
<|"Name"->"Nf","Type"->"Constant","AD"->False|>,
<|"Name"->"T","Type"->"Constant","AD"->False|>,
<|"Name"->"muq","Type"->"Constant","AD"->False|>,

(*anomalous dimensions*)
<|"Name"->"etaQ","Type"->"Variable","AD"->True|>,
<|"Name"->"etaPhi","Type"->"Variable","AD"->True|>,

(*Yukawa coupling*)
<|"Name"->"hPhi","Type"->"Variable","AD"->True|>,

(*Meson couplings*)
<|"Name"->"d1V","Type"->"Variable","AD"->True|>,
<|"Name"->"d2V","Type"->"Variable","AD"->True|>,
<|"Name"->"d3V","Type"->"Variable","AD"->True|>,
<|"Name"->"rhoPhi","Type"->"Constant","AD"->False|>
};


bosonp0Rule[mom_]:=vec[mom,0]:>0;
quarkp0PlusRule[mom_]:=vec[mom,0]:>p0f-I muq;
quarkp0MinusRule[mom_]:=vec[mom,0]:>-p0f+I muq;
fermionp0PlusRule[mom_]:=vec[mom,0]:>p0f;
fermionp0MinusRule[mom_]:=vec[mom,0]:>-p0f;
Clear[MakeP0Projection]
MakeP0Projection[bosonList_:{},quarkInList_:{},quarkOutList_:{},fermionInList_:{},fermionOutList_:{}]:=Module[{bp,qp,fp,ap},
bp=Map[bosonp0Rule,bosonList];
qp=Join[Map[quarkp0PlusRule,quarkInList],Map[quarkp0MinusRule,quarkOutList]];
fp=Join[Map[fermionp0PlusRule,fermionInList],Map[fermionp0MinusRule,fermionOutList]];
ap=Join[bp,qp,fp];
Return[((#//SeparateScalarProductsFiniteT)//.ap)&]
]


couplingsList:={

};
dotsList:={
RQdot[__],RPhidot[__]
};
otherList={
GQ[__],GPion[__],GSigma[__],
RQ[__],RPhi[__],
RQdot[__],RPhidot[__]
};
QCDSimp[expr_]:=Module[{ret},
ret=expr//UseLorentzLinearity//ExpandScalarProductsFiniteT//SimplifyAllMomenta[q,#]&;
ret=ret/.Map[(Head[#][a___]:>FullSimplify[Head[#][a]])&,otherList\[Union]dotsList];
ret=Collect[ret,couplingsList\[Union]dotsList,QuickSimplify];
ret=Collect[ret,couplingsList\[Union]dotsList,Simplify];
Return[ret];
];
QCDQuickSimp[expr_]:=Module[{ret},
ret=expr//UseLorentzLinearity//ExpandScalarProductsFiniteT//SimplifyAllMomenta[q,#]&;
ret=ret/.Map[(Head[#][a___]:>FullSimplify[Head[#][a]])&,otherList\[Union]dotsList];
ret=Collect[ret,couplingsList\[Union]dotsList,QuickSimplify];
Return[ret];
];
SetStandardSimplify[QCDSimp];
SetStandardQuickSimplify[QCDQuickSimp];


MakeFlowClassFiniteT["QuarkMeson",kernels]


(*Diagrams*)
DerivativeListqbq= {qb[-p,{d2,c2,f2}],q[p,{d1,c1,f1}]};
Diagramsqbqsidx =DeriveFunctionalEquation[SetupfRG,DerivativeListqbq,"OutputLevel"->"SuperindexDiagrams"];
Diagramsqbqsidx=ReduceIdenticalFlowDiagrams[Diagramsqbqsidx];
Diagramsqbq=SuperindexToFullDiagrams[Diagramsqbqsidx,SetupfRG,DerivativeListqbq];
Print["Diagramsqbq got "<>ToString[Length[Diagramsqbq]]<>" diagrams."]
PlotSuperindexDiagram[Diagramsqbqsidx,SetupfRG,"EdgeStyle"->DiagramStyle]


(*Projection onto spatial part*)
T\[Eta]q[p1_,d1_,c1_,f1_,p2_,d2_,c2_,f2_]:=-I psdash[p2,d1,d2]deltaFundCol[c1,c2]deltaFundFlav[f1,f2];
NormetaQ=T\[Eta]q[p,d1,c1,f1,-p,d2,c2,f2]T\[Eta]q[-p,d2,c2,f2,p,d1,c1,f1]//FormTrace;
ProjectoretaQ=-(T\[Eta]q[p,d1,c1,f1,-p,d2,c2,f2]/NormetaQ);

p0Projection=MakeP0Projection[{},{p}];
etaQ[vec[p,0],Sqrt[sps[p,p]]]//p0Projection//QCDSimp
SetStandardSimplify[QCDSimp[p0Projection[#]]&];

(*Sanity check*)
sanity=ProjectoretaQ( \[CapitalGamma]qbq[{-p,d2, c2,f2,p,d1,c1, f1}]-\[CapitalGamma]qbq[{-0,d2, c2,f2,0,d1,c1, f1}])//.PreTraceRules//FormTrace//p0Projection//Simplify;
sanity=sanity//.PostTraceRules//Simplify;
Print["Projection check is ", sanity, ", should be -1"]


ProjectionetaQ=(ProjectoretaQ Diagramsqbq)//.PreTraceRules;
TraceDiagrams[6,"etaQ",ProjectionetaQ]
etaQLoop=SumDiagrams[6,"etaQ",0,QCDSimp[#//.PostTraceRules//p0Projection]&]//.cospq->cos1;
MakeKernel[kerneletaQ,kernelParameterList,Re[etaQLoop]]


SumDiagrams[6,"etaQ",0,#&,"sum_unprocessed"]


(*Diagrams*)
DerivativeListPhiPhi= {\[CapitalPi][-p,{a}],\[CapitalPi][p,{b}]};
DiagramsPhiPhisidx =DeriveFunctionalEquation[SetupfRG,DerivativeListPhiPhi,"OutputLevel"->"SuperindexDiagrams"];
DiagramsPhiPhisidx=ReduceIdenticalFlowDiagrams[DiagramsPhiPhisidx,DerivativeListPhiPhi,{{{1,2},Plus}}];
DiagramsPhiPhi=SuperindexToFullDiagrams[DiagramsPhiPhisidx,SetupfRG,DerivativeListPhiPhi];
Print["DiagramsPhiPhi got "<>ToString[Length[DiagramsPhiPhi]]<>" diagrams."]
PlotSuperindexDiagram[DiagramsPhiPhisidx,SetupfRG,"EdgeStyle"->DiagramStyle]


(*Projection*)
NormetaPhi=deltaAdjFlav[a,b]deltaAdjFlav[b,a]//FormTrace;
ProjectoretaPhi=deltaAdjFlav[b,a]/NormetaPhi//.PreTraceRules;

p0Projection=MakeP0Projection[{p},{}];
etaPhi[vec[p,0],Sqrt[sps[p,p]]]//p0Projection//QCDSimp
SetStandardSimplify[QCDSimp[p0Projection[#]]&];

(*Sanity check*)
sanity=(ProjectoretaPhi (\[CapitalGamma]\[CapitalPi]\[CapitalPi][{-p,a,p,b}]-\[CapitalGamma]\[CapitalPi]\[CapitalPi][{-0,a,0,b}])/  sps[p,p])//.PreTraceRules//FormTrace;
sanity=sanity//.PostTraceRules//p0Projection//QCDSimp;
Print["Projection check is ", sanity, ", should be 1"]


ProjectionetaPhi=(ProjectoretaPhi DiagramsPhiPhi)//.PreTraceRules//p0Projection;
TraceDiagrams[6,"etaPhi",ProjectionetaPhi]

etaPhiLoop=SumDiagrams[6,"etaPhi",QCDSimp[#//.PostTraceRules//p0Projection]&]//.cospq->cos1;
etaPhiLoop=-QCDQuickSimp[(etaPhiLoop-(etaPhiLoop//.p->0))/ sps[p,p]];
MakeKernel[kerneletaPhi,kernelParameterList,Re[etaPhiLoop]]


SumDiagrams[6,"etaPhi",0,#&,"sum_unprocessed"]


(*Diagrams*)
DerivativeListqbq= {qb[-p,{d2,c2,f2}],q[p,{d1,c1,f1}]};
Diagramsqbqsidx =DeriveFunctionalEquation[SetupfRG,DerivativeListqbq,"OutputLevel"->"SuperindexDiagrams"];
Diagramsqbqsidx=ReduceIdenticalFlowDiagrams[Diagramsqbqsidx];
Diagramsqbq=SuperindexToFullDiagrams[Diagramsqbqsidx,SetupfRG,DerivativeListqbq];
Print["Diagramsqbq got "<>ToString[Length[Diagramsqbq]]<>" diagrams."]
PlotSuperindexDiagram[Diagramsqbqsidx,SetupfRG,"EdgeStyle"->DiagramStyle]


(*Projector*)
Normh\[Phi]=(-deltaFundCol[c2,c1] deltaFundFlav[f2,f1] deltaDirac[d2,d1])(-deltaFundCol[c1,c2] deltaFundFlav[f1,f2] deltaDirac[d1,d2]) //FormTrace;
Projectorh\[Phi]=Sqrt[2Nf] (-deltaFundCol[c2,c1] deltaFundFlav[f2,f1] deltaDirac[d2,d1])/(Sqrt[2rhoPhi] Normh\[Phi]);

p0Projection=MakeP0Projection[{},{p}];
hPhi[vec[p,0],Sqrt[sps[p,p]]]//p0Projection//QCDSimp
SetStandardSimplify[QCDSimp[p0Projection[#]]&];

(*Sanity check*)
sanity=Projectorh\[Phi] \[CapitalGamma]qbq[{-p,d1,c1, f1,p,d2, c2,f2}]//.PreTraceRules//FormTrace//Simplify;
sanity=sanity//.PostTraceRules//Simplify;
Print["Projection check is ", sanity, ", should be hPhi"]


Projectionh\[Phi]=(Projectorh\[Phi] Diagramsqbq)//.PreTraceRules;
TraceDiagrams[8,"hPhi",Projectionh\[Phi]]

h\[Phi]Loop=SumDiagrams[8,"hPhi",QCDQuickSimp[#//.PostTraceRules//p0Projection]&]//.cospq->cos1;
h\[Phi]Renorm=(etaPhi/2+etaQ)hPhi;MakeKernel[kernelhPhi,kernelParameterList,Re[h\[Phi]Loop],h\[Phi]Renorm];


SumDiagrams[8,"hPhi",#&,"sum_unprocessed"]


DiagramsVsidx=DeriveFunctionalEquation[SetupfRG,{},"OutputLevel"->"SuperindexDiagrams"];
DiagramsVsidx=ReduceIdenticalFlowDiagrams[DiagramsVsidx];
DiagramsV=SuperindexToFullDiagrams[DiagramsVsidx,SetupfRG,{}];
PlotSuperindexDiagram[DiagramsVsidx,SetupfRG,"EdgeStyle"->DiagramStyle]


$Assumptions=$Assumptions&&A0>=0&& gAqbq1>=0&&muq>=0&&q>p>0&&q>0&&k>0&&-1<cos<1&&-m2Sigma-q^2-RB[k^2,q^2]<0&&-d1V-q^2-RB[k^2,q^2]<0&&-m2Quark-q^2-2 q RF[k^2,q^2]-RF[k^2,q^2]^2<0;

ProjectedV=DiagramsV//.PreTraceRules;
VLoop=ExpandScalarProductsFiniteT[Map[FormTrace[PreTrace[#]]&,ProjectedV]]//Simplify;
VLoop=VLoop//.PostTraceRules//.hPhi->Sqrt[(m2Quark 2Nf)/(2rhoPhi)]//.2 d2V rhoPhi->m2Sigma-d1V//QCDSimp
VLoop=(Map[MatsubaraSum[#,q0,T]&,VLoop]//Expand)//.Tanh[a__]:>Tanh[FullSimplify[a]]//SafeFiniteTFunctions[#,T]&//QCDSimp;

VLoop=VLoop//.m2Quark->hPhi^2/(2Nf) 2rhoPhi//.m2Sigma->d1V+2rhoPhi d2V//QCDSimp
MakeKernel[kernelV,kernelParameterList,VLoop]



